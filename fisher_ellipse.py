# This code generates Fisher ellipse plots from the fisher information generated by the covariance code.
# Because my thesis is due in 3 days, I'm not bothering to make this all fancy and modular. Some other time, perhaps.
# Instead, I've just hard coded some of the Fisher matrices used. Feel free to re run these using the covaraince code if you want.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse

# Booleans that determine whether or not to run certain proof of concept tests. These were used to test as I wrote the code.
test_bool_1 = False
test_bool_2 = False

# --------------------- 2x2 Hardcoded Fisher Matrices ---------------------

fisher_matrix_TEST = np.array([
[4,7],
[2,6]
],dtype=float)

# ---------- Log S = 3.5 Matrices ----------
# first entry is d_0, second entry is omega B. Short derivatives. logS fixed at 3.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s3_5_short = np.array([
[2.36484187695e+17, 3.10895994367e+12],
[3.10895994367e+12, 266155950.823]
],dtype=float)

# first entry is d_0, second entry is omega B. Long derivatives. logS fixed at 3.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s3_5_long = np.array([
[2.36484208087e+17, 3.15587419947e+12],
[3.15587419947e+12, 264266772.331]
],dtype=float)

# first entry is d_0, second entry is omega M. Short derivatives. logS fixed at 3.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s3_5_short = np.array([
[2.36484187695e+17, -460556063325.0],
[-460556063325.0, 8876846.73617]
],dtype=float)

# first entry is d_0, second entry is omega M. Long derivatives. logS fixed at 3.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s3_5_long = np.array([
[2.36484208087e+17, -498700092610.0],
[-498700092610.0, 9056174.88365]
],dtype=float)

# first entry is d_0, second entry is h_0. Short derivatives. logS fixed at 3.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s3_5_short = np.array([
[2.36484187695e+17, 117050744572.0],
[117050744572.0, 7581269.62454]
],dtype=float)

# first entry is d_0, second entry is h_0. Long derivatives. logS fixed at 3.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s3_5_long = np.array([
[2.36484208087e+17, 150468748255.0],
[150468748255.0, 7537801.77524]
],dtype=float)


# ---------- Log S = 5.0 Matrices ----------
# first entry is d_0, second entry is omega B. Short derivatives. logS fixed at 5.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s5_short = np.array([
[1.77002925092e+17, 2.78572829129e+12],
[2.78572829129e+12, 266155950.823]
],dtype=float)

# first entry is d_0, second entry is omega B. Long derivatives. logS fixed at 5.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s5_long = np.array([
[1.77002907303e+17, 2.82529161781e+12],
[2.82529161781e+12, 264266772.331]
],dtype=float)

# first entry is d_0, second entry is omega M. Short derivatives. logS fixed at 5.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s5_short = np.array([
[1.77002925092e+17, -414239568027.0],
[-414239568027.0, 8876846.73617]
],dtype=float)

# first entry is d_0, second entry is omega M. Long derivatives. logS fixed at 5.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s5_long = np.array([
[1.77002907303e+17, -446823867483.0],
[-446823867483.0, 9056174.88365]
],dtype=float)

# first entry is d_0, second entry is h_0. Short derivatives. logS fixed at 5.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s5_short = np.array([
[1.77002925092e+17, 100647388243.0],
[100647388243.0, 7581269.62454]
],dtype=float)

# first entry is d_0, second entry is h_0. Long derivatives. logS fixed at 5.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s5_long = np.array([
[1.77002907303e+17, 129060929113.0],
[129060929113.0, 7537801.77524]
],dtype=float)


# ---------- Log S = 6.6 Matrices ----------
# first entry is d_0, second entry is omega B. Short derivatives. logS fixed at 6.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s6_5_short = np.array([
[32283660.8476, 70671229.8231],
[70671229.8231, 266155950.823]
],dtype=float)

# first entry is d_0, second entry is omega B. Long derivatives. logS fixed at 6.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s6_5_long = np.array([
[245662708.174, 70344481.1872],
[70344481.1872, 264266772.331]
],dtype=float)

# first entry is d_0, second entry is omega M. Short derivatives. logS fixed at 6.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s6_5_short = np.array([
[32283660.8476, -7699841.48003],
[-7699841.48003, 8876846.73617]
],dtype=float)

# first entry is d_0, second entry is omega M. Long derivatives. logS fixed at 6.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s6_5_long = np.array([
[245662708.174, -7711908.34196],
[-7711908.34196, 9056174.88365]
],dtype=float)

# first entry is d_0, second entry is h_0. Short derivatives. logS fixed at 6.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s6_5_short = np.array([
[32283660.8476, -2444383.33398],
[-2444383.33398, 7581269.62454]
],dtype=float)

# first entry is d_0, second entry is h_0. Long derivatives. logS fixed at 6.5 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s6_5_long = np.array([
[245662708.174, -2407731.51272],
[-2407731.51272, 7537801.77524]
],dtype=float)


# ---------- Log S = 8.0 Matrices ----------
# first entry is d_0, second entry is omega B. Short derivatives. logS fixed at 8.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s8_short = np.array([
[32323324.1321, 70710563.7895],
[70710563.7895, 266155950.823]
],dtype=float)

# first entry is d_0, second entry is omega B. Long derivatives. logS fixed at 8.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omB_s8_long = np.array([
[32293588.1739, 70349742.8009],
[70349742.8009, 264266772.331]
],dtype=float)

# first entry is d_0, second entry is omega M. Short derivatives. logS fixed at 8.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s8_short = np.array([
[32323324.1321, -7703946.76232],
[-7703946.76232, 8876846.73617]
],dtype=float)

# first entry is d_0, second entry is omega M. Long derivatives. logS fixed at 8.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_omM_s8_long = np.array([
[32293588.1739, -7712853.47595],
[-7712853.47595, 9056174.88365]
],dtype=float)

# first entry is d_0, second entry is h_0. Short derivatives. logS fixed at 8.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s8_short = np.array([
[32323324.1321, -2441298.19973],
[-2441298.19973, 7581269.62454]
],dtype=float)

# first entry is d_0, second entry is h_0. Long derivatives. logS fixed at 8.0 Instrument is Planck 217 GHz B.
fisher_matrix_d0_h_0_s8_long = np.array([
[32293588.1739, -2407651.39866],
[-2407651.39866, 7537801.77524]
],dtype=float)



# -------------------- Ellipse Generation --------------------

def fisher_ellipse_params(fisher_matrix):                    # Takes a 2x2 fisher matrix as an input, returns the parameters of the uncertainty ellipse
                                                             # this function follows the steps outlined in https://arxiv.org/pdf/0906.4123.pdf, sec. 2
    covariance_matrix = np.linalg.inv( fisher_matrix )       # convert fisher into covariance matrix

    # define explicit components of the covariance matrix, which we use to buld the ellipse
    sig_x2 = covariance_matrix[0,0]
    sig_xy = covariance_matrix[0,1]                         # according to 0906.4123, matrices are symmetric across diagonal
    sig_y2 = covariance_matrix[1,1]

    # Calculate a, b, theta, the ellipse parameters
    a = np.sqrt( ((sig_x2 + sig_y2)/2.) + np.sqrt( (((sig_x2 - sig_y2)**2.)/4.) + (sig_xy**2.) ) )
    b = np.sqrt( ((sig_x2 + sig_y2)/2.) - np.sqrt( (((sig_x2 - sig_y2)**2.)/4.) + (sig_xy**2.) ) )
    theta = 0.5*np.arctan2( 2*sig_xy, sig_x2-sig_y2 )
    theta = theta*360.*(1./(2.*np.pi))                      # Convert into degrees for Ellipse plotter

    # format of ellipse_params will be ellipse_params[0] -> 1 sigma confidence, ellipse_params[1] -> 2 sigma confidence, ellipse_params[n] -> [a,b,theta]
    # eg: ellipse_params[0][0] = 1 sigma confidence semi major axis. ellipse_params[1][3] = 2 sigma condifence theta ellipse_params[0][2]
    ellipse_params = np.zeros( (2,3) )

    # 1 sigma case. multiply by 1.52 for reasons explained in 0906.4123
    ellipse_params[0,0] = a*1.52
    ellipse_params[0,1] = b*1.52
    ellipse_params[0,2] = theta

    # 2 sigma case. multiply by 2.48 for reasons explained in 0906.4123
    ellipse_params[1,0] = a*2.48
    ellipse_params[1,1] = b*2.48
    ellipse_params[1,2] = theta

    return ellipse_params




# -------------------- Testing Suite --------------------

if test_bool_1 == True:
    covariance_matrix_TEST = np.linalg.inv( fisher_matrix_TEST )

    print(' ')
    print('-------- Begin test 1, matrix inversion --------')
    print('Start with the matrix below:')
    print(fisher_matrix_TEST)
    print(' ')
    print('Inverted Matrix should be [[0.6,-0.7],[-0.2,0.4]]')
    print(' ')
    print('Numpy inverted matrix result:')
    print(covariance_matrix_TEST)
    print(' ')
    print('-------- End test 1, matrix inversion --------')

if test_bool_2 == True:
    d0_h0_s3_5_short_params = fisher_ellipse_params(fisher_matrix_d0_h0_s3_5_short)
    d0_h0_s3_5_long_params = fisher_ellipse_params(fisher_matrix_d0_h0_s3_5_long)

    ellipse_short_1sig = Ellipse((0.,0.), d0_h0_s3_5_short_params[0,0], d0_h0_s3_5_short_params[0,1], d0_h0_s3_5_short_params[0,2], alpha=0.1, color='Blue')
    ellipse_short_2sig = Ellipse((0.,0.), d0_h0_s3_5_short_params[1,0], d0_h0_s3_5_short_params[1,1], d0_h0_s3_5_short_params[1,2], alpha=0.1, color='Blue')

    ellipse_long_1sig = Ellipse((0.,0.), d0_h0_s3_5_long_params[0,0], d0_h0_s3_5_long_params[0,1], d0_h0_s3_5_long_params[0,2], alpha=0.1, color='Red')
    ellipse_long_2sig = Ellipse((0.,0.), d0_h0_s3_5_long_params[1,0], d0_h0_s3_5_long_params[1,1], d0_h0_s3_5_long_params[1,2], alpha=0.1, color='Red')

    # Verbose Feedback
    print(' ')
    print('------ D_0 / H_0 Fisher Ellipse ------')
    print('Short Derivatives, 1 sigma Semi-Major Axis:'+str(d0_h0_s3_5_short_params[0,0]))
    print('Short Derivatives, 1 sigma Semi-Minor Axis:'+str(d0_h0_s3_5_short_params[0,1]))
    print('Short Derivatives, 1 sigma Angle:'+str(d0_h0_s3_5_short_params[0,2]))

    # Building the plot, telling plot to accept ellipse shapes
    a = plt.subplot(111, aspect='equal')
    a.add_artist(ellipse_short_1sig)
    a.add_artist(ellipse_short_2sig)
    a.add_artist(ellipse_long_1sig)
    a.add_artist(ellipse_long_2sig)

    # Proper axes
    plt.xlim(-d0_h0_s3_5_short_params[0,0], d0_h0_s3_5_short_params[0,0])
    plt.ylim(-d0_h0_s3_5_short_params[0,0], d0_h0_s3_5_short_params[0,0])
    plt.show()

# -------------------- Results and Plots --------------------
# For best results, run one plot at a time. They get finnicky, even with the plt.clf() in between each plot to reset everything


# ---- LogS = 3.5 Plot ----
do_s3_5_plot = False
if do_s3_5_plot == True:
    d0_omB_s3_5_short_params = fisher_ellipse_params(fisher_matrix_d0_omB_s3_5_short)
    d0_omM_s3_5_short_params = fisher_ellipse_params(fisher_matrix_d0_omM_s3_5_short)
    d0_h_0_s3_5_short_params = fisher_ellipse_params(fisher_matrix_d0_h_0_s3_5_short)

    ellipse_omB_1sig = Ellipse((0.,0.), d0_omB_s3_5_short_params[0,0], d0_omB_s3_5_short_params[0,1], d0_omB_s3_5_short_params[0,2], alpha=0.2, color='Blue')
    ellipse_omB_2sig = Ellipse((0.,0.), d0_omB_s3_5_short_params[1,0], d0_omB_s3_5_short_params[1,1], d0_omB_s3_5_short_params[1,2], alpha=0.2, color='Blue', label='$D_0, \Omega_b$ Correlation')

    ellipse_omM_1sig = Ellipse((0.,0.), d0_omM_s3_5_short_params[0,0], d0_omM_s3_5_short_params[0,1], d0_omM_s3_5_short_params[0,2], alpha=0.2, color='Red')
    ellipse_omM_2sig = Ellipse((0.,0.), d0_omM_s3_5_short_params[1,0], d0_omM_s3_5_short_params[1,1], d0_omM_s3_5_short_params[1,2], alpha=0.2, color='Red', label='$D_0, \Omega_m$ Correlation')

    ellipse_h_0_1sig = Ellipse((0.,0.), d0_h_0_s3_5_short_params[0,0], d0_h_0_s3_5_short_params[0,1], d0_h_0_s3_5_short_params[0,2], alpha=0.2, color='Green')
    ellipse_h_0_2sig = Ellipse((0.,0.), d0_h_0_s3_5_short_params[1,0], d0_h_0_s3_5_short_params[1,1], d0_h_0_s3_5_short_params[1,2], alpha=0.2, color='Green', label='$D_0, H_0$ Correlation')


    # Building the plot, telling plot to accept ellipse shapes
    a = plt.subplot(111)
    a.add_artist(ellipse_omB_1sig)
    a.add_artist(ellipse_omB_2sig)
    a.add_artist(ellipse_omM_1sig)
    a.add_artist(ellipse_omM_2sig)
    a.add_artist(ellipse_h_0_1sig)
    a.add_artist(ellipse_h_0_2sig)


    # Proper axes
    plt.xlim(-d0_omM_s3_5_short_params[0,1], d0_omM_s3_5_short_params[0,1])
    plt.ylim(-d0_omM_s3_5_short_params[0,0], d0_omM_s3_5_short_params[0,0])
    plt.legend(handles=[ellipse_omB_2sig,ellipse_omM_2sig,ellipse_h_0_2sig])
    plt.xlabel('$D_0$ deviation from fiducial GR value')
    plt.ylabel('$\Omega_b, \Omega_m, H_0/100$ deviation from fiducial value')
    plt.title('Fisher Ellipses for Planck 217 GHz, $\log_{10}(s)=3.5$')
    plt.grid(color='Gray', linestyle=':', linewidth=1)
    plt.tight_layout()
    plt.savefig('fisher_ellipse_s3_5.pdf')
    plt.clf()


# ---- LogS = 5.0 Plot ----
do_s5_plot = False
if do_s5_plot == True:
    d0_omB_s5_short_params = fisher_ellipse_params(fisher_matrix_d0_omB_s5_short)
    d0_omM_s5_short_params = fisher_ellipse_params(fisher_matrix_d0_omM_s5_short)
    d0_h_0_s5_short_params = fisher_ellipse_params(fisher_matrix_d0_h_0_s5_short)

    ellipse_omB_1sig = Ellipse((0.,0.), d0_omB_s5_short_params[0,0], d0_omB_s5_short_params[0,1], d0_omB_s5_short_params[0,2], alpha=0.2, color='Blue')
    ellipse_omB_2sig = Ellipse((0.,0.), d0_omB_s5_short_params[1,0], d0_omB_s5_short_params[1,1], d0_omB_s5_short_params[1,2], alpha=0.2, color='Blue', label='$D_0, \Omega_b$ Correlation')

    ellipse_omM_1sig = Ellipse((0.,0.), d0_omM_s5_short_params[0,0], d0_omM_s5_short_params[0,1], d0_omM_s5_short_params[0,2], alpha=0.2, color='Red')
    ellipse_omM_2sig = Ellipse((0.,0.), d0_omM_s5_short_params[1,0], d0_omM_s5_short_params[1,1], d0_omM_s5_short_params[1,2], alpha=0.2, color='Red', label='$D_0, \Omega_m$ Correlation')

    ellipse_h_0_1sig = Ellipse((0.,0.), d0_h_0_s5_short_params[0,0], d0_h_0_s5_short_params[0,1], d0_h_0_s5_short_params[0,2], alpha=0.2, color='Green')
    ellipse_h_0_2sig = Ellipse((0.,0.), d0_h_0_s5_short_params[1,0], d0_h_0_s5_short_params[1,1], d0_h_0_s5_short_params[1,2], alpha=0.2, color='Green', label='$D_0, H_0$ Correlation')


    # Building the plot, telling plot to accept ellipse shapes
    a = plt.subplot(111)
    a.add_artist(ellipse_omB_1sig)
    a.add_artist(ellipse_omB_2sig)
    a.add_artist(ellipse_omM_1sig)
    a.add_artist(ellipse_omM_2sig)
    a.add_artist(ellipse_h_0_1sig)
    a.add_artist(ellipse_h_0_2sig)


    # Proper axes
    plt.xlim(-d0_omM_s5_short_params[0,1], d0_omM_s5_short_params[0,1])
    plt.ylim(-d0_omM_s5_short_params[0,0], d0_omM_s5_short_params[0,0])
    plt.legend(handles=[ellipse_omB_2sig,ellipse_omM_2sig,ellipse_h_0_2sig])
    plt.xlabel('$D_0$ deviation from fiducial GR value')
    plt.ylabel('$\Omega_b, \Omega_m, H_0/100$ deviation from fiducial value')
    plt.title('Fisher Ellipses for Planck 217 GHz, $\log_{10}(s)=5.0$')
    plt.grid(color='Gray', linestyle=':', linewidth=1)
    plt.tight_layout()
    plt.savefig('fisher_ellipse_s5.pdf')
    plt.clf()



# ---- LogS = 6.5 Plot ----
do_s6_5_plot = False
if do_s6_5_plot == True:
    d0_omB_s6_5_short_params = fisher_ellipse_params(fisher_matrix_d0_omB_s6_5_short)
    d0_omM_s6_5_short_params = fisher_ellipse_params(fisher_matrix_d0_omM_s6_5_short)
    d0_h_0_s6_5_short_params = fisher_ellipse_params(fisher_matrix_d0_h_0_s6_5_short)

    ellipse_omB_1sig = Ellipse((0.,0.), d0_omB_s6_5_short_params[0,0], d0_omB_s6_5_short_params[0,1], d0_omB_s6_5_short_params[0,2], alpha=0.2, color='Blue')
    ellipse_omB_2sig = Ellipse((0.,0.), d0_omB_s6_5_short_params[1,0], d0_omB_s6_5_short_params[1,1], d0_omB_s6_5_short_params[1,2], alpha=0.2, color='Blue', label='$D_0, \Omega_b$ Correlation')

    ellipse_omM_1sig = Ellipse((0.,0.), d0_omM_s6_5_short_params[0,0], d0_omM_s6_5_short_params[0,1], d0_omM_s6_5_short_params[0,2], alpha=0.2, color='Red')
    ellipse_omM_2sig = Ellipse((0.,0.), d0_omM_s6_5_short_params[1,0], d0_omM_s6_5_short_params[1,1], d0_omM_s6_5_short_params[1,2], alpha=0.2, color='Red', label='$D_0, \Omega_m$ Correlation')

    ellipse_h_0_1sig = Ellipse((0.,0.), d0_h_0_s6_5_short_params[0,0], d0_h_0_s6_5_short_params[0,1], d0_h_0_s6_5_short_params[0,2], alpha=0.2, color='Green')
    ellipse_h_0_2sig = Ellipse((0.,0.), d0_h_0_s6_5_short_params[1,0], d0_h_0_s6_5_short_params[1,1], d0_h_0_s6_5_short_params[1,2], alpha=0.2, color='Green', label='$D_0, H_0$ Correlation')


    # Building the plot, telling plot to accept ellipse shapes
    a = plt.subplot(111)
    a.add_artist(ellipse_omB_1sig)
    a.add_artist(ellipse_omB_2sig)
    a.add_artist(ellipse_omM_1sig)
    a.add_artist(ellipse_omM_2sig)
    a.add_artist(ellipse_h_0_1sig)
    a.add_artist(ellipse_h_0_2sig)


    # Proper axes
    plt.xlim(-d0_omM_s6_5_short_params[0,1], d0_omM_s6_5_short_params[0,1])
    plt.ylim(-d0_omM_s6_5_short_params[0,0], d0_omM_s6_5_short_params[0,0])
    plt.legend(handles=[ellipse_omB_2sig,ellipse_omM_2sig,ellipse_h_0_2sig])
    plt.xlabel('$D_0$ deviation from fiducial GR value')
    plt.ylabel('$\Omega_b, \Omega_m, H_0/100$ deviation from fiducial value')
    plt.title('Fisher Ellipses for Planck 217 GHz, $\log_{10}(s)=6.5$')
    plt.grid(color='Gray', linestyle=':', linewidth=1)
    plt.tight_layout()
    plt.savefig('fisher_ellipse_s6_5.pdf')
    plt.clf()




# ---- LogS = 8.0 Plot ----
do_s8_plot = True
if do_s8_plot == True:
    d0_omB_s8_short_params = fisher_ellipse_params(fisher_matrix_d0_omB_s8_short)
    d0_omM_s8_short_params = fisher_ellipse_params(fisher_matrix_d0_omM_s8_short)
    d0_h_0_s8_short_params = fisher_ellipse_params(fisher_matrix_d0_h_0_s8_short)

    ellipse_omB_1sig = Ellipse((0.,0.), d0_omB_s8_short_params[0,0], d0_omB_s8_short_params[0,1], d0_omB_s8_short_params[0,2], alpha=0.2, color='Blue')
    ellipse_omB_2sig = Ellipse((0.,0.), d0_omB_s8_short_params[1,0], d0_omB_s8_short_params[1,1], d0_omB_s8_short_params[1,2], alpha=0.2, color='Blue', label='$D_0, \Omega_b$ Correlation')

    ellipse_omM_1sig = Ellipse((0.,0.), d0_omM_s8_short_params[0,0], d0_omM_s8_short_params[0,1], d0_omM_s8_short_params[0,2], alpha=0.2, color='Red')
    ellipse_omM_2sig = Ellipse((0.,0.), d0_omM_s8_short_params[1,0], d0_omM_s8_short_params[1,1], d0_omM_s8_short_params[1,2], alpha=0.2, color='Red', label='$D_0, \Omega_m$ Correlation')

    ellipse_h_0_1sig = Ellipse((0.,0.), d0_h_0_s8_short_params[0,0], d0_h_0_s8_short_params[0,1], d0_h_0_s8_short_params[0,2], alpha=0.2, color='Green')
    ellipse_h_0_2sig = Ellipse((0.,0.), d0_h_0_s8_short_params[1,0], d0_h_0_s8_short_params[1,1], d0_h_0_s8_short_params[1,2], alpha=0.2, color='Green', label='$D_0, H_0$ Correlation')


    # Building the plot, telling plot to accept ellipse shapes
    a = plt.subplot(111)
    a.add_artist(ellipse_omB_1sig)
    a.add_artist(ellipse_omB_2sig)
    a.add_artist(ellipse_omM_1sig)
    a.add_artist(ellipse_omM_2sig)
    a.add_artist(ellipse_h_0_1sig)
    a.add_artist(ellipse_h_0_2sig)


    # Proper axes
    plt.xlim(-d0_omM_s8_short_params[0,1], d0_omM_s8_short_params[0,1])
    plt.ylim(-d0_omM_s8_short_params[0,0], d0_omM_s8_short_params[0,0])
    plt.legend(handles=[ellipse_omB_2sig,ellipse_omM_2sig,ellipse_h_0_2sig])
    plt.xlabel('$D_0$ deviation from fiducial GR value')
    plt.ylabel('$\Omega_b, \Omega_m, H_0/100$ deviation from fiducial value')
    plt.title('Fisher Ellipses for Planck 217 GHz, $\log_{10}(s)=8.0$')
    plt.grid(color='Gray', linestyle=':', linewidth=1)
    plt.tight_layout()
    plt.savefig('fisher_ellipse_s8.pdf')
    plt.clf()





#
